\documentclass[german,plainarticle,hyperref,utf8]{zihpub}
\author{Daniel Körsten}
\title{Komplexpraktikum Paralleles Rechnen - Aufgabe B}
\matno{4690396}
\betreuer{Dr. Robert Schöne}
\bibfiles{bib-filenames}

\begin{document}
	\section{Aufgabenbeschreibung}
	In dieser Aufgabe soll eine Thread-parallele Version von \texttt{Conway’s Game-of-Life} in der Programmiersprache \texttt{C} programmiert werden. Das Game-of-Life ist ein vom Mathematiker John Horton Conway entworfenes Spiel \cite{gardner}.
	Anschließend soll die Simulation mit verschieden großen Feldgrößen und Compiler durchgeführt und verglichen werden.
	
	\subsection{Conway’s Game-of-Life}
	Das Spiel besteht dabei aus einem Spielbrett mit einer festgelegten, möglichst großen, Anzahl an Zeilen und Spalten. Eine Zelle kann dabei entweder Tot oder Lebendig sein. Dieses Spielfeld wird mit einer zufälligen Anfangspopulation initialisiert.
	
	Ein Sonderfall stellen die Ecken und Kanten des Feldes dar, da dort nach den Spielregeln das Verhalten nicht festgelegt ist. Die Aufgabenstellung gibt vor, dass Spielfeld Torus-förmig sein soll. Alles was das Spielfeld auf einer Seite verlässt, kommt auf der gegenüberliegenden Seite wieder herein.
	
	Anschließend wird durch die Befolgung der Spielregeln die nächste Generation berechnet. Dafür betrachtet man jede Zelle und ihre 8 Nachbarn, um ihre Entwicklung zu berechnen. Es gelten folgende Spielregeln:
	\begin{enumerate}
		\item Eine lebende Zelle mit zwei oder drei Nachbarn überlebt in der Folgegeneration.
		\item Eine lebende Zelle mit vier oder mehr Nachbarn stirbt an der Überpopulation. Bei weniger als zwei Nachbarn stirbt sie an Einsamkeit.
		\item Jede tote Zelle mit genau drei Nachbarn wird in der nächsten Generation geboren.
	\end{enumerate}
	Wichtig ist, dass die Folgegenration für alle Zellen berechnet wird und anschließend die aktuelle Generation ersetzt. Es ist also nicht möglich die nachfolgende Generation im Spielfeld der Aktuellen zu berechnen.
	
	\subsection{Besonderheiten der Aufgabenstellung}
	Die Aufgabenstellung gibt vor, dass die Parallelisierung mittels \texttt{OpenMP} erfolgen soll. \texttt{OpenMP} ist eine API, welche es ermöglicht, Schleifen mithilfe von Threads zu parallelisieren \cite{openmp}. Es eignet sich hervorragend für \texttt{Shared-Memory Systeme}, also Systeme, bei denen mehrere Threads auf einen gemeinsamen Hauptspeicher zugreifen.
	
	Weitere Besonderheiten sind:
	\begin{itemize}
		\item Die Simulation soll variabel mit Feldgrößen von $128\times 128$ bis $32768\times 32768$ und 1 bis 32 Threads erfolgen.
		\item Das OpenMP Schedulingverfahren soll hinsichtlich des Einflusses auf die Ausführungszeit untersucht werden.
		\item Das Programm soll mit dem dem \texttt{GCC} und \texttt{ICC} kompiliert und anschließend getestet werden.
	\end{itemize}

	\section{Implementierung}
	 Zuerst habe ich mich mit der Abstraktion des Feldes in \texttt{C} beschäftigt. Meine Idee ist die Allokierung eines Speicherbereichs der Größe \texttt{columns * rows * sizeof(u\_int8\_t)} mittels der Funktion \texttt{malloc()}. Innerhalb des Speicherbereichs kann man sich nun frei bewegen. Dabei verwendet man die \texttt{columns} als Offset um an die entsprechende Stelle zu springen.
	 Beispiel: Möchte man auf die Zweite Zelle in Zweiten Zeile (da die Nummerierung typischerweise bei 0 beginnt, also das erste Element) zugreifen, würde man das \texttt{columns + 1} Byte innerhalb des Speicherbereichs verwenden.
	 
	 Um zu Berücksichtigen, dass die Polgeneration immer der aktuelle Generation ersetzt, verwende ich Zwei dieser Speicherbereiche. Vor dem Beginn einer neuen Berechnung, vertausche ich die beide Speicherbereiche, was dazu führt, dass die im vorhergehenden Schritt berechnete Folgegeneration zur aktuellen Generation wird und eine neue Generation berechnet werden kann.
	
	
	
	
	
	\subsection{Vorbereitung des Codes für eine parallele Ausführung}
	Für die Berechnung der nächsten Generation muss nun jede Zelle einzeln betrachtet werden und ihr Zustand in der nächsten Generation gemäß den Spielregeln berechnet werden.
	Ein möglicher Ansatz ist über jede Zeile und anschließend jede Spalte zu iterieren. Realisieren lässt sich das über zwei geschachtelte \verb|for|-Schleifen. Das Ergebnis dieser Berechnung muss in einer zweiten Matrix gespeichert werden um die Berechnungen der Nachbarzellen nicht zu verfälschen.
	
	Dieser Ansatz bietet den Vorteil, dass er mit OpenMP relativ einfach parallelisiert werden kann, denn die Berechnung jeder einzelnen Zelle ist unabhängig von den Berechnungen anderer Zellen.
	
	Besonderes Augenmerk muss man jedoch auf die Kanten und Ecken legen. Diese sollen, laut Aufgabenstellung, mit \verb|periodic boundary conditions| implementiert werden. Jedoch kann auch hier OpenMP zur Parallelisierung der Kanten verwendet werden.

	\subsection{Ein und Ausgabe}
	Da die Messung später in verschiedenen Feldgrößen durchgeführt wird, habe ich mich für den Einsatz von \verb|getopt| entschieden. Es ermöglicht die Anzahl der Schleifendurchläufe, die Feldgröße und eine optionale Fortschrittsanzeige über Argumente beim Programmstart einzustellen.
	Ebenso lassen sich Threadanzahl und OpenMP Schedulingverfahren einstellen.
	
	\subsection{Probleme und ihre Lösung}
	Die Erzeugung des 2D-Arrays soll dynamisch erfolgen, damit man, ohne Anpassung des Programmcodes, die Feldgröße festlegen kann. Gemäß der Aufgabenstellung umfasst das größte Feld $32768\times 32768$ Zellen. Damit ist das Array zu groß für den Stack des Programms.
	Mein Lösungsansatz war die Allokation von Speicher mittels \verb|malloc| und \verb|double pointers|: Ein erstes Array wurde mit Pointern gefüllt, die jeweils wiederum auf die einzelnen Zeilen verweisen, welche ebenfalls mit \verb|malloc| allokiert wurden.
	Später habe ich die \verb|double pointers| durch ein einzelnes \verb|malloc| ersetzt, indem die Anzahl von Spalten als Offset dient, um sich im 2D-Array zu bewegen. Dadurch vermeidet man einen Speicherzugriff und folglich eine Adressübersetzung bei jeder Datenabfrage und -manipulation.
	
	Nach der Parallelisierung mit OpenMP änderte sich jedoch nichts an der Ausführungszeit, was eindeutig den Erwartungen widersprach. Durch Experimentieren fand ich heraus, dass die Parallelisierung der Funktion, welche das Array mit Zufallswerten füllt, die Performance massiv beeinflusst. Die Funktion \verb|rand| ist nicht für die parallele Ausführung geeignet. Deshalb habe ich mich hier einfach für die sequentielle Ausführung entschieden.
	
	\subsection{Optimierung des Codes}
	Eine Möglichkeit zur Einsparung von Rechenressourcen ist, den Speicherverbrauch des Programms zu reduzieren. So verwendete ich für die Zellen der Felder den Datentyp \verb|u_int8_t| statt \verb|int|. Dadurch reduziert sich der Speicherverbrauch jeder Zelle von 4 auf 1 Byte. Bei einem Feld der Größe $32768\times 32768$ entspricht dies einer stattlichen Einsparung von über 3 GiB.
	
	Die Verwendung von von bitweisen Operatoren in den Berechnung bringen ebenfalls einen geringen Geschwindigkeitsvorteil, da bitweise Operationen in der Schaltungstechnik die Einfachsten darstellen. Alle höheren Operationen lassen sich auf sie zurückführen.
	

\end{document}
